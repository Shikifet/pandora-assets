import { readFileSync, writeFileSync } from 'fs';
import { Immutable, freeze } from 'immer';
import { diffString } from 'json-diff';
import { isEqual } from 'lodash-es';
import {
	Assert,
	AssetGraphicsDefinition,
	AssetManager,
	AssetSourceGraphicsDefinitionSchema,
	GetLogger,
	LoadAssetLayer,
	LoadAssetRoomDeviceLayer,
	Logger,
	ModuleNameSchema,
	SCHEME_OVERRIDE,
	type AssetDefinition,
	type AssetId,
	type AssetSourceGraphicsDefinition,
	type AssetSourceGraphicsInfo,
	type GraphicsBuildContextAssetData,
	type GraphicsBuildContextRoomDeviceData,
	type Writable,
} from 'pandora-common';
import { basename, relative } from 'path';
import * as z from 'zod';
import { boneDefinition } from '../bones.ts';
import { SRC_DIR, TRY_AUTOCORRECT_WARNINGS } from '../config.ts';
import { MakeGraphicsBuildContext } from './load_helpers/graphicsBuildContext.ts';
import { AssetGraphicsValidate } from './validation/assetGraphics.ts';
import { WatchFile } from './watch.ts';

export async function LoadAssetGraphicsFile(
	path: string,
	builtAssetData: Immutable<GraphicsBuildContextAssetData>,
	assets: Immutable<Record<AssetId, AssetDefinition>>,
): Promise<{ graphics: Immutable<AssetGraphicsDefinition>; graphicsSource: AssetSourceGraphicsInfo; }> {
	const logger = GetLogger('GraphicsValidation').prefixMessages(`Graphics definition '${relative(SRC_DIR, path)}':\n\t`);

	WatchFile(path);

	const fileBasename = basename(path);
	if (fileBasename !== 'graphics.json') {
		logger.warning(`Worn item graphics should be stored in files named 'graphics.json', found '${fileBasename}'`);
	}

	const rawDefinition = readFileSync(path, { encoding: 'utf-8' });
	const definition: unknown = JSON.parse(
		rawDefinition
			.split('\n')
			.filter((line) => !line.trimStart().startsWith('//'))
			.join('\n'),
	);

	ModuleNameSchema[SCHEME_OVERRIDE]((module, ctx) => {
		if (builtAssetData.modules?.[module] == null) {
			ctx.addIssue({
				code: 'custom',
				message: `Module '${module}' is not a valid module name`,
			});
		}
	});

	const parseResult = AssetSourceGraphicsDefinitionSchema.safeParse(definition);

	if (!parseResult.success) {
		logger.error(
			`File is not valid AssetSourceGraphicsDefinition:\n`,
			z.prettifyError(parseResult.error),
		);
		throw new Error(`Graphics in '${path}' are not AssetSourceGraphicsDefinition`);
	}

	const canonizedExport = `// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n`
		+ JSON.stringify(parseResult.data, undefined, '\t').trim()
		+ '\n';
	if (!isEqual(definition, parseResult.data)) {
		Assert(rawDefinition !== canonizedExport);
		const diff = diffString(definition, parseResult.data, { color: false });
		logger.warning('Definition updated during parse:\n', diff);
	} else if (rawDefinition !== canonizedExport) {
		logger.warning(`Definition is not in its canonic form. Please use editor to correct this.`);
	}

	if (rawDefinition !== canonizedExport && TRY_AUTOCORRECT_WARNINGS) {
		writeFileSync(path, canonizedExport, { encoding: 'utf-8' });
		logger.info('The above warning has been auto-corrected; re-run to check if successful.');
	}

	const graphicsSource: AssetSourceGraphicsDefinition = freeze(parseResult.data, true);

	AssetGraphicsValidate(graphicsSource, logger);

	const buildAssetManager = new AssetManager('', {
		assets,
		bones: boneDefinition,
	});

	const { graphics, originalImagesMap } = await LoadAssetGraphics(graphicsSource, builtAssetData, buildAssetManager, logger);

	return {
		graphics,
		graphicsSource: {
			type: 'worn',
			definition: graphicsSource,
			originalImagesMap,
		},
	};
}

export async function LoadAssetGraphics(
	source: Immutable<AssetSourceGraphicsDefinition>,
	builtAssetData: Immutable<GraphicsBuildContextAssetData>,
	buildAssetManager: AssetManager,
	logger: Logger,
): Promise<{ graphics: Immutable<AssetGraphicsDefinition>; originalImagesMap: Record<string, string>; }> {
	const originalImagesMap: Record<string, string> = {};

	const assetLoadContext = MakeGraphicsBuildContext<Immutable<GraphicsBuildContextAssetData>>(
		builtAssetData,
		buildAssetManager,
		'asset',
		originalImagesMap,
	);

	const layers = (await Promise.all(source.layers.map((l) => LoadAssetLayer(l, assetLoadContext, logger)))).flat();

	const graphics: Writable<Immutable<AssetGraphicsDefinition>> = {
		type: 'worn',
		layers,
	};

	const roomLayers = source.roomLayers;
	if (roomLayers != null) {
		if (!builtAssetData.supportsInRoomGraphics) {
			logger.warning('Room graphics is defined, but asset does not support room deployment');
		}

		const roomLoadContext = MakeGraphicsBuildContext<Immutable<GraphicsBuildContextRoomDeviceData>>(
			{
				modules: builtAssetData.modules,
				colorizationKeys: builtAssetData.colorizationKeys,
				slotIds: new Set(),
			},
			buildAssetManager,
			'roomDevice',
			originalImagesMap,
		);
		const roomLayersLogger = logger.prefixMessages(`Room graphics:\n\t\t`);

		graphics.roomLayers = (await Promise.all(roomLayers.map((l) => LoadAssetRoomDeviceLayer(l, roomLoadContext, roomLayersLogger)))).flat();
	} else if (builtAssetData.supportsInRoomGraphics) {
		logger.warning('Asset supports room deployment, but in-room graphics are not defined');
	}

	return {
		graphics,
		originalImagesMap,
	};
}
